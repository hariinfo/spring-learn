package com.example.demo.services;

import com.example.demo.data.AppointmentDTO;
import com.example.demo.data.PatientDTO;
import com.example.demo.exception.PatientAlreadyExistsException;
import org.simpleflatmapper.jdbc.spring.JdbcTemplateMapperFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
@PropertySource("classpath:db/queries/patient.properties")
public class PatientService {
    @Autowired
    NamedParameterJdbcTemplate jdbcTemplate;

    //@Autowired
   // JdbcTemplate simpleJDBCTemplate;

    @Value("${patient.get}")
    private String GET_PATIENT_SQL;

    @Value("${patient.add}")
    private String ADD_PATIENT_SQL;

    @Value("${patient.getall}")
    private String GETALL_PATIENT_SQL;

    @Value("${patient.current.check}")
    private String GET_CURRENT_PATIENT_SQL;



    //We use BeanPropertyRowMapper instead of a custom row mapper here.
    public List<PatientDTO> getAllPatients(){
        return jdbcTemplate.query(GETALL_PATIENT_SQL,
                new BeanPropertyRowMapper<>(PatientDTO.class)
                );
    }

    public Optional<PatientDTO> getPatient(int patientID){
          PatientDTO patientDTO = DataAccessUtils.singleResult(jdbcTemplate.query(GET_PATIENT_SQL,
                new MapSqlParameterSource("patient_id", patientID),
                new BeanPropertyRowMapper<>(PatientDTO.class)));
        return Optional.ofNullable(patientDTO);
    }

    //The patient_id is a next_val auto generated by the database
    //hence, we return the generated id in the POJO response
    public Long addPatient(PatientDTO patientDTO) throws PatientAlreadyExistsException {

        //Check if patient with same email id is already registered
        SqlParameterSource namedParameters = new MapSqlParameterSource("primary_email", patientDTO.getPrimary_email());

        PatientDTO patient = DataAccessUtils.singleResult(jdbcTemplate.query(GET_CURRENT_PATIENT_SQL,
                namedParameters,
                BeanPropertyRowMapper.newInstance(PatientDTO.class)));

       // PatientDTO patient = DataAccessUtils.singleResult(jdbcTemplate.query(GET_CURRENT_PATIENT_SQL, new BeanPropertyRowMapper<>(PatientDTO.class),
         //       new Object[]{patientDTO.getPrimary_email()}));

        //We already have a patient with the given primary email id
        if(patient != null){
            throw new PatientAlreadyExistsException(String.format("Patient with email - %s already exists", patientDTO.getPrimary_email()));
        }

        //TODO: Can this be done using NamedParameterJdbcTemplate ?
       /*
        SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(simpleJDBCTemplate).withTableName("patient").usingGeneratedKeyColumns("patient_id");
        Number id = simpleJdbcInsert.executeAndReturnKey(params);
        */

        MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("first_name", patientDTO.getFirstName())
                .addValue("last_name", patientDTO.getLastName())
                .addValue("primary_email", patientDTO.getPrimary_email());
        KeyHolder holder = new GeneratedKeyHolder();

        jdbcTemplate.update(ADD_PATIENT_SQL,
                params,
                holder,new String[] { "patient_id" });
        return holder.getKey().longValue();
        //return id.longValue();
    }






}
